# 함수
## 12.1 함수란?
**함수는 자바스크립트에서 가장 중요한 핵심 개념**이다. 또 다른 핵시 개념인 스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로토타입, 모듈화 등이 모두홤수와 깊은 관려이 있다.

프로그래밍 언어의 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.

## 12.2 함수를 사용하는 이유
**코드의 재사용**이라는 측면에서 매우 유용하기 때문이다. 코드의 중복을 억제하고 재사용성을 높이는 함수는 유지보수의 편의성을 높이고 코드의 신뢰성을 높이는 효과가 있다.

## 12.3 함수 리터럴
자바스크립트의 함수는 객체 타입의 값이다. 따라서 함수도 함수 리터럴로 생성할 수 있다.
```jsx
// 변수에 함수 리터럴을 할당
var f = function add(x, y){
    return x+y;
};
```
함수는 객체이지만 일반 객체와는 다르다. 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다. 함수가 객체라는 사실은 다른 프로그래밍 언어와 구별되는 자바스크립트의 중요한 특징이다.
*(참고) 18. 함수와 일급 객체*
## 12.4 함수 정의
함수를 정의하는 4가지 방법

1. 함수 선언문
2. 함수 표현식
3. Function 생성자 함수
4. 화살표 함수(ES6)

### 12.4.1 함수 선언문
함수 선언문은 함수 리터럴과 형태가 동일하다. 단, 함수 리터럴은 함수 이름을 생략할 수 있으나 함수 선언문은 함수 이름을 생략할 수 없다.

함수 선언문은 표현식이 아닌 문이다. 크롬 개발자 도구의 콘솔에서 함수 선언문을 실행하면 완료 값 undefined가 출력된다. 함수 선언문이 만약 표현식인 문이라면 완료 값 undefined 대신 표현식이 평가되어 생성된 함수가 출력돠어야 한다.

```jsx
function add(x,y){
    return x+y;
}
// undefined 가 콘솔에 찍힌다.
```
5.6절 => 표현식이 아닌 문은 변수에 할당할 수 없다. 그러므로 함수 선언문도 표현식이 아닌 문이므로 변수에 할당할 수 없다. 하지만 다음 예제를 실행해보면 함수 선언문이 변수에 할당되는 것처럼 보인다.
```jsx
var add = function add(x,y){
    return x+y;
};

console.log(add(2,5)); // 7
```
이렇게 동작하는 이유는 자바스크립트 엔진이 코드의 문맥에 따라 동일한 함수 리터럴을 표현식이 아닌 문법 함수 선언문으로 해석하는 경우와 표현식인 문인 함수 리터럴 표현식으로 해석하는 경우가 있기 떄문이다. 

함수 선언문이 이름 생략이 안된다는 점을 제외하면 함수 리터럴과 형태가 동일하다. => 기명 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 가능성이 있다!

예를 들어, {}은 블록문, 혹은 객체 리터럴일 수도 있다. 자바스크립트는 이처럼 중의적인 코드는 코드의 문맥에 따라 해석이 달라진다. 

```jsx
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() {console.log('foo');}

foo(); // foo

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
// 함수 리터럴에서는 함수 이름을 생략할 수 있다.
(function bar() {console.log('foo');});
bar(); // ReferenceError: bar is not defined
```
위 예제에서 foo 함수 리터럴은 함수선언문으로 해석. 하지만 그룹 연산자() 내에 있는 bar 함수리터럴은 함수 리터럴 표현식으로 해석된다. 이처럼 이름이 있는 기명 함수 리터럴은 해석이 달리 된다. 함수 객체를 생성한다는 점에서 동일하지만 호출에 차이가 있다.

**함수 리터럴에서 함수이름은 함수몸체 내에서만 참조할 수 있는 식별자**다. 이는 함수 몸체 외부에서는 함수 이름으로 함수를 참조할 수 없으므로 함수 몸체 외부에서는 함수 이름으로 함수를 호출할 수 없다는 의미다.

실제로 콘솔에 bar 함수를 호출해보면 ReferenceError가 뜨는 것을 확인 할 수 있다. 그렇다면 함수몸체 내에서만 함수이름을 사용할 수 있어야하므로 foo 함수 또한 같은 에러가 떠야한다. 하지만 foo 함수는 정상적으로 호출이 된다. 

이는 자바스크립트 엔진이 암묵적으로 식별자를 생성하기 때문이다.

```jsx
// add: 식별자
// add2: 함수 이름
var add = function functionName(x,y){
    return x+y;
};
console.log(add(2,5)) //7
console.log(functionName(2,5,)) // not defined
```
자바스크립트 엔진은 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성, 거기에 함수 객체를 할당한다.

함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다. 결론적으로 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 반환해 함수 객체를 생성한다고 할 수 있다. 단, 함수선언문과 함수 표현식이 정확히 동작하는 것은 아니다.

### 12.4.2 함수 표현식
자바스크립트의 함수는 객체 타입의 값이다. 자바스크립트이 함수는 값처럼 변수에 할당, 프로퍼티 값, 배열의 요소가 될 수도 있다. 이처럼 값의 성질을 갖는 객체를 일급 객체라고 한다.

함수는 일급 객체 이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수 표현식이라 한다.

함수 리터럴의 함 수 이름은 생략할 수 있다. 이를 익명 함수라 한다.









